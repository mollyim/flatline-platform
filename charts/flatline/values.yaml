# global defines shared values for this chart and its dependencies.
global:
  defaultStorageClass: ""
# common defines shared values for this chart.
common:
  # defaultInitContainer defines the values to be used by default in various init containers.
  # Components defined with an "initContainer" object create a container that will use these defaults.
  # The "waitForComponents" object also creates an init container that will use these defaults.
  defaultInitContainer:
    image:
      repository: docker.io/library/busybox
      tag: 1.36.1
      pullPolicy: IfNotPresent
#
#  Flatline Components
#  These components are the core of Flatline.
#  Their container images are built by the Flatline project.
#
# whisperService defines the values for the Whisper Service component.
whisperService:
  enabled: true
  image:
    repository: ghcr.io/mollyim/flatline-whisper-service
    tag: main
    pullPolicy: Always
  replicas: 1
  service:
    type: ClusterIP
    ports:
      default:
        port: 8080
        protocol: TCP
      admin:
        port: 8081
        protocol: TCP
  # env defines the environment variables passed to the container.
  # In this chart, environment variable values are treated as Helm templates.
  env:
    - name: AWS_REGION
      value: us-east-1
    - name: AWS_ACCESS_KEY_ID
      value: test
    - name: AWS_SECRET_ACCESS_KEY
      value: test
    - name: AWS_ENDPOINT_OVERRIDE
      value: "http://{{ include \"common.fullname\" . }}-localstack:4566"
    - name: SIGNAL_DISABLE_LOGSTASH_TCP_SOCKET_APPENDER
      value: "1"
  # configMap defines a ConfigMap associated with the component.
  # The contents of all entries are treated as Helm templates.
  # Some sample files are bundled with the chart. These files are intended for development use only.
  # Use "values.yaml" or the "--set-file" argument to replace the bundled files with your own.
  # Example: helm install dev . --set-file whisperService.configMap.data.configuration=./custom.yml
  configMap:
    data:
      configuration: "{{ tpl (.Files.Get \"files/whisper-service/dev.yml\") . }}"
  # secret defines a Secret associated with the component.
  # The contents of all entries are treated as Helm templates.
  # Some sample files are bundled with the chart. These files are intended for development use only.
  # Use "values.yaml" or the "--set-file" argument to replace the bundled files with your own.
  # Example: helm install dev . --set-file whisperService.secret.stringData.secrets-bundle=./custom.yml
  secret:
    data:
      noise-tunnel-keystore: "{{ .Files.Get \"files/whisper-service/noise-tunnel-keystore.p12\" | b64enc }}"
    stringData:
      secrets-bundle: "{{ .Files.Get \"files/whisper-service/sample-secrets-bundle.yml\" }}"
  volumeMounts:
    - name: config
      readOnly: true
      configMap:
        name: "{{ include \"common.fullnameWithComponent\" . }}"
        items:
          - key: configuration
            path: configuration
            mountPath: /usr/share/signal/dev.yml
            readOnly: true
    - name: secrets
      readOnly: true
      secret:
        name: "{{ include \"common.fullnameWithComponent\" . }}"
        items:
          - key: secrets-bundle
            path: secrets-bundle
            mountPath: /usr/share/signal/sample-secrets-bundle.yml
            readOnly: true
          - key: noise-tunnel-keystore
            path: noise-tunnel-keystore
            mountPath: /usr/share/signal/noise-tunnel-keystore.p12
            readOnly: true
  # initContainer defines a process that must succeed during pod initialization.
  initContainer:
    image:
      repository: docker.io/library/redis
      tag: 8.2.1
    command: sh
    # args defines the arguments passed to the entrypoint command.
    # Each argument is treated as a Helm template.
    args:
      - -c
      # Ensure that the Redis cluster has all of its nodes.
      - |
        REDIS_HOST="{{ include "common.fullname" . }}-redis-cluster"
        REDIS_PORT={{ .Values.redisCluster.service.ports.default.port }}
        EXPECTED_NODES={{ .Values.redisCluster.replicas }}
        redis-cli -h "${REDIS_HOST}" -p ${REDIS_PORT} --raw CLUSTER INFO \
          | grep -E 'cluster_state|cluster_known_nodes' && \
        test "$(redis-cli -h "${REDIS_HOST}" -p ${REDIS_PORT} CLUSTER NODES | wc -l)" -eq ${EXPECTED_NODES}
  # waitForCompoenents defines the a map of component services to wait for during pod initialization.
  # Both the host and the port for each container are treated as Helm templates.
  waitForComponents:
    localstack:
      type: tcp
      host: "{{ include \"common.fullname\" . }}-localstack"
      port: "{{ .Values.localstack.service.ports.default.port }}"
    cbtemulator:
      type: tcp
      host: "{{ include \"common.fullname\" . }}-cbtemulator"
      port: "{{ .Values.cbtemulator.service.ports.default.port }}"
    tus:
      type: tcp
      host: "{{ include \"common.fullname\" . }}-tus"
      port: "{{ .Values.tus.service.ports.default.port }}"
    redisCluster:
      type: tcp
      host: "{{ include \"common.fullname\" . }}-redis-cluster"
      port: "{{ .Values.redisCluster.service.ports.default.port }}"
    otelCollector:
      type: tcp
      host: "{{ include \"common.fullname\" . }}-otel-collector"
      port: "{{ .Values.otelCollector.service.ports.http.port }}"
    registrationService:
      type: tcp
      host: "{{ include \"common.fullname\" . }}-registration-service"
      port: "{{ .Values.registrationService.service.ports.default.port }}"
    keyTransparencyServer:
      type: tcp
      host: "{{ include \"common.fullname\" . }}-key-transparency-server"
      port: "{{ .Values.keyTransparencyServer.service.ports.default.port }}"
  # startupProbe defines the criteria to mark the pod as running for the first time.
  # The "waitForComponents" init container relies on this probe to consider the component ready.
  # Ports and commands used in the probe are treated as Helm templates.
  startupProbe:
    initialDelaySeconds: 1
    periodSeconds: 1
    timeoutSeconds: 1
    failureThreshold: 10
    tcpSocket:
      port: "{{ .componentValues.service.ports.default.port }}"
# storageService defines the values for the Storage Service component.
storageService:
  enabled: true
  image:
    repository: ghcr.io/mollyim/flatline-storage-service
    tag: main
    pullPolicy: Always
  replicas: 1
  service:
    type: ClusterIP
    ports:
      default:
        port: 10080
        protocol: TCP
      admin:
        port: 10081
        protocol: TCP
  # env defines the environment variables passed to the container.
  # In this chart, environment variable values are treated as Helm templates.
  env:
    - name: AWS_REGION
      value: us-east-1
    - name: HTTP_HOST
      value: "0.0.0.0"
    - name: HTTP_PORT
      value: "{{ .Values.storageService.service.ports.default.port }}"
    - name: ADMIN_HOST
      value: "0.0.0.0"
    - name: ADMIN_HTTP_PORT
      value: "{{ .Values.storageService.service.ports.admin.port }}"
    - name: BIGTABLE_EMULATOR_HOST
      value: "{{ include \"common.fullname\" . }}-cbtemulator:{{ .Values.cbtemulator.service.ports.default.port }}"
  # configMap defines a ConfigMap associated with the component.
  # The contents of all entries are treated as Helm templates.
  # Some sample files are bundled with the chart. These files are intended for development use only.
  # Use "values.yaml" or the "--set-file" argument to replace the bundled files with your own.
  # Example: helm install dev . --set-file storageService.configMap.data.configuration=./custom.yml
  configMap:
    data:
      configuration: "{{ tpl (.Files.Get \"files/storage-service/dev.yml\") . }}"
  volumeMounts:
    - name: config
      readOnly: false
      configMap:
        name: "{{ include \"common.fullnameWithComponent\" . }}"
        items:
          - key: configuration
            path: configuration
            mountPath: /usr/share/signal/dev.yml
            readOnly: true
  # waitForCompoenents defines the a map of component services to wait for during pod initialization.
  # Both the host and the port for each container are treated as Helm templates.
  waitForComponents:
    cbtemulator:
      type: tcp
      host: "{{ include \"common.fullname\" . }}-cbtemulator"
      port: "{{ .Values.cbtemulator.service.ports.default.port }}"
  # startupProbe defines the criteria to mark the pod as running for the first time.
  # The "waitForComponents" init container relies on this probe to consider the component ready.
  # Ports and commands used in the probe are treated as Helm templates.
  startupProbe:
    initialDelaySeconds: 1
    periodSeconds: 1
    timeoutSeconds: 1
    failureThreshold: 20
    tcpSocket:
      port: "{{ .componentValues.service.ports.default.port }}"
# registrationService defines the values for the Registration Service component.
registrationService:
  enabled: true
  image:
    repository: ghcr.io/mollyim/flatline-registration-service
    tag: main
    pullPolicy: Always
  replicas: 1
  service:
    type: ClusterIP
    ports:
      default:
        port: 50051
        protocol: TCP
  # startupProbe defines the criteria to mark the pod as running for the first time.
  # The "waitForComponents" init container relies on this probe to consider the component ready.
  # Ports and commands used in the probe are treated as Helm templates.
  startupProbe:
    initialDelaySeconds: 1
    periodSeconds: 1
    timeoutSeconds: 1
    failureThreshold: 10
    tcpSocket:
      port: "{{ .componentValues.service.ports.default.port }}"
# contactDiscoveryService defines the values for the Contact Discovery Service component.
contactDiscoveryService:
  enabled: true
  image:
    repository: ghcr.io/mollyim/flatline-contact-discovery-service
    tag: main
    pullPolicy: Always
  replicas: 1
  service:
    type: ClusterIP
    ports:
      default:
        port: 8080
        protocol: TCP
  # env defines the environment variables passed to the container.
  # In this chart, environment variable values are treated as Helm templates.
  env:
    - name: _JAVA_OPTIONS
      value: -Dmicronaut.environments=dev
    - name: SGX_MODE
      # Run SGX in simulation mode.
      value: SIM
  # startupProbe defines the criteria to mark the pod as running for the first time.
  # The "waitForComponents" init container relies on this probe to consider the component ready.
  # Ports and commands used in the probe are treated as Helm templates.
  startupProbe:
    initialDelaySeconds: 1
    periodSeconds: 1
    timeoutSeconds: 1
    failureThreshold: 10
    tcpSocket:
      port: "{{ .componentValues.service.ports.default.port }}"
# keyTransparencyServer defines the values for the Key Transparency Server component.
keyTransparencyServer:
  enabled: true
  image:
    repository: ghcr.io/mollyim/flatline-key-transparency-server
    tag: main
    pullPolicy: Always
  replicas: 1
  container:
    command: /bin/kt-server
    # args defines the arguments passed to the entrypoint command.
    # Each argument is treated as a Helm template.
    args:
      - -config
      - /usr/share/kt/config.yaml
  service:
    type: ClusterIP
    ports:
      default:
        port: 8080
        protocol: TCP
  # configMap defines a ConfigMap associated with the component.
  # The contents of all entries are treated as Helm templates.
  # Some sample files are bundled with the chart. These files are intended for development use only.
  # Use "values.yaml" or the "--set-file" argument to replace the bundled files with your own.
  # Example: helm install dev . --set-file keyTransparencyServer.configMap.data.configuration=./custom.yaml
  configMap:
    data:
      configuration: "{{ tpl (.Files.Get \"files/key-transparency-server/config.yaml\") . }}"
  volumeMounts:
    - name: config
      readOnly: false
      configMap:
        name: "{{ include \"common.fullnameWithComponent\" . }}"
        items:
          - key: configuration
            path: configuration
            mountPath: /usr/share/kt/config.yaml
            readOnly: true
  # startupProbe defines the criteria to mark the pod as running for the first time.
  # The "waitForComponents" init container relies on this probe to consider the component ready.
  # Ports and commands used in the probe are treated as Helm templates.
  startupProbe:
    initialDelaySeconds: 1
    periodSeconds: 1
    timeoutSeconds: 1
    failureThreshold: 10
    tcpSocket:
      port: "{{ .componentValues.service.ports.default.port }}"
#
#  Infrastructure Components
#  These components provide functionality that Flatline requires.
#  Their container images are build and distributed by third parties.
#  They are bundled in the chart to provide a functional development environment.
#  They should be replaced with production-ready alternatives when appropriate.
#
# localstack defines the creation and bootstrapping of an environment emulating Amazon Web Services.
# The DynamoDB and S3 features from AWS are required by the Whisper Service component.
# Disable this component to use AWS or another compatible solution.
localstack:
  enabled: true
  image:
    repository: docker.io/localstack/localstack
    tag: 4.6.0
    pullPolicy: IfNotPresent
  service:
    type: ClusterIP
    ports:
      default:
        port: 4566
        protocol: TCP
  replicas: 1
  # startupProbe defines the criteria to mark the pod as running for the first time.
  # The "waitForComponents" init container relies on this probe to consider the component ready.
  # Ports and commands used in the probe are treated as Helm templates.
  startupProbe:
    initialDelaySeconds: 5
    periodSeconds: 1
    timeoutSeconds: 1
    failureThreshold: 60
    exec:
      command:
        - sh
        - -c
        - "curl -s localhost:{{ .componentValues.service.ports.default.port }}/_localstack/init/ready | grep '\"completed\": true'"
  # env defines the environment variables passed to the container.
  # In this chart, environment variable values are treated as Helm templates.
  env:
    - name: DISABLE_EVENTS
      value: "1"
    - name: LS_LOG
      value: info
  persistence:
    # storageClassName defines the storage class that will be used by the created persistent volume. Optional.
    # When not set, the global "defaultStorageClass" will be used.
    storageClassName: ""
    accessModes:
      - ReadWriteOnce
    size: 1Gi
  # configMap defines a ConfigMap associated with the component.
  # The contents of all entries are treated as Helm templates.
  # Some sample files are bundled with the chart. These files are intended for development use only.
  # Use "values.yaml" or the "--set-file" argument to replace the bundled files with your own.
  # Example: helm install dev . --set-file localstack.configMap.data.whisper-service-dynamic-configuration=./custom.yaml
  configMap:
    data:
      whisper-service-dynamic-configuration: "{{ .Files.Get \"files/localstack/whisper-service-dynamic-config-dev.yaml\" }}"
      whisper-service-cloudformation: "{{ .Files.Get \"files/localstack/whisper-service-aws-cloudformation.yaml\" }}"
      whisper-service-init-script: "{{ .Files.Get \"files/localstack/whisper-service-init.sh\" }}"
  volumeMounts:
    - name: config
      readOnly: false
      configMap:
        name: "{{ include \"common.fullnameWithComponent\" . }}"
        defaultMode: "0755"
        items:
          - key: whisper-service-dynamic-configuration
            path: whisper-service-dynamic-configuration
            mountPath: /opt/whisper-service-dynamic-config-dev.yaml
            readOnly: true
          - key: whisper-service-cloudformation
            path: whisper-service-cloudformation
            mountPath: /opt/whisper-service-aws-cloudformation.yaml
            readOnly: true
          - key: whisper-service-init-script
            path: whisper-service-init-script
            mountPath: /etc/localstack/init/ready.d/whisper-service-init.sh
            readOnly: true
    - name: data
      mountPath: /var/lib/localstack
      readOnly: false
      persistentVolumeClaim:
        claimName: "{{ include \"common.fullnameWithComponent\" . }}"
# cbtemulator defines the creation of an environment emulating Google Cloud Bigtable.
# The Bigtable feature from GCP is required by the Storage Service component.
# Disable this component to use Bigtable on GCP or another compatible solution.
cbtemulator:
  enabled: true
  image:
    repository: docker.io/fullstorydev/cbtemulator
    tag: v1.0.0
    pullPolicy: IfNotPresent
  service:
    type: ClusterIP
    ports:
      default:
        port: 9000
        protocol: TCP
  replicas: 1
  container:
    command: cbtemulator
    # args defines the arguments passed to the entrypoint command.
    # Each argument is treated as a Helm template.
    args:
      - -host
      - 0.0.0.0
      - -port
      - "{{ .componentValues.service.ports.default.port }}"
      - -dir
      - /var/bigtable
  persistence:
    # storageClassName defines the storage class that will be used by the created persistent volume. Optional.
    # When not set, the global "defaultStorageClass" will be used.
    storageClassName: ""
    accessModes:
      - ReadWriteOnce
    size: 1Gi
  volumeMounts:
    - name: data
      mountPath: /var/bigtable
      readOnly: false
      persistentVolumeClaim:
        claimName: "{{ include \"common.fullnameWithComponent\" . }}"
  # startupProbe defines the criteria to mark the pod as running for the first time.
  # The "waitForComponents" init container relies on this probe to consider the component ready.
  # Ports and commands used in the probe are treated as Helm templates.
  startupProbe:
    initialDelaySeconds: 5
    periodSeconds: 1
    timeoutSeconds: 1
    failureThreshold: 5
    tcpSocket:
      port: "{{ .componentValues.service.ports.default.port }}"
# tus defines the values for the a resumable file uploads server.
# Such a server is required by the Whisper Service component.
# Disable this component to use an alternative implementation.
tus:
  enabled: true
  image:
    repository: ghcr.io/tus/tusd
    tag: v2.8.0
    pullPolicy: IfNotPresent
  replicas: 1
  container:
    command: /usr/local/share/docker-entrypoint.sh
    # args defines the arguments passed to the entrypoint command.
    # Each argument is treated as a Helm template.
    args:
      - --upload-dir
      - /srv/tusd-data/data
      - --base-path
      - /files/attachments/
      - --verbose
  service:
    type: ClusterIP
    ports:
      default:
        port: 8080
        protocol: TCP
  persistence:
    # storageClassName defines the storage class that will be used by the created persistent volume. Optional.
    # When not set, the global "defaultStorageClass" will be used.
    storageClassName: ""
    accessModes:
      - ReadWriteOnce
    size: 10Gi
  volumeMounts:
    - name: data
      mountPath: /srv/tusd-data/data
      readOnly: false
      persistentVolumeClaim:
        claimName: "{{ include \"common.fullnameWithComponent\" . }}"
  # startupProbe defines the criteria to mark the pod as running for the first time.
  # The "waitForComponents" init container relies on this probe to consider the component ready.
  # Ports and commands used in the probe are treated as Helm templates.
  startupProbe:
    initialDelaySeconds: 1
    periodSeconds: 1
    timeoutSeconds: 1
    failureThreshold: 10
    tcpSocket:
      port: "{{ .componentValues.service.ports.default.port }}"
# redisCluster defines the values for an insecure development Redis cluster.
# Such a cluster is required by the Whisper Service component.
# Disable this component to use a production Redis cluster.
redisCluster:
  enabled: true
  image:
    repository: docker.io/library/redis
    tag: 8.2.1
    pullPolicy: IfNotPresent
  replicas: 6
  cluster:
    replicasPerMaster: 1
  container:
    command: redis-server
    # args defines the arguments passed to the entrypoint command.
    # Each argument is treated as a Helm template.
    args:
      - /etc/redis/redis.conf
  service:
    type: ClusterIP
    clusterIP: None
    ports:
      default:
        port: 6379
        protocol: TCP
  persistence:
    # storageClassName defines the storage class that will be used by the created persistent volume. Optional.
    # When not set, the global "defaultStorageClass" will be used.
    storageClassName: ""
    accessModes:
      - ReadWriteOnce
    size: 1Gi
  # configMap defines a ConfigMap associated with the component.
  # The contents of all entries are treated as Helm templates.
  # Some sample files are bundled with the chart. These files are intended for development use only.
  # Use "values.yaml" or the "--set-file" argument to replace the bundled files with your own.
  # Example: helm install dev . --set-file redisCluster.configMap.data.configuration=./custom.conf
  configMap:
    data:
      configuration: "{{ .Files.Get \"files/redis-cluster/redis.conf\" }}"
  volumeMounts:
    - name: data
      mountPath: /data
      readOnly: false
    - name: config
      readOnly: true
      configMap:
        name: "{{ include \"common.fullnameWithComponent\" . }}"
        items:
          - key: configuration
            path: configuration
            mountPath: /etc/redis/redis.conf
            readOnly: true
  job:
    command: sh
    # args defines the arguments passed to the entrypoint command.
    # Each argument is treated as a Helm template.
    args:
      - -c
      - "{{ tpl (.Files.Get \"files/redis-cluster/init.sh.tpl\") . }}"
  # startupProbe defines the criteria to mark the pod as running for the first time.
  # The "waitForComponents" init container relies on this probe to consider the component ready.
  # Ports and commands used in the probe are treated as Helm templates.
  startupProbe:
    initialDelaySeconds: 5
    periodSeconds: 1
    timeoutSeconds: 1
    failureThreshold: 60
    tcpSocket:
      port: "{{ .componentValues.service.ports.default.port }}"
# otelCollector defines the values for an OpenTelemetry collector.
# A collector compatible with StatsD is required by the Whisper Service component.
# Disable this component to use an existing StatsD collector.
otelCollector:
  enabled: true
  image:
    repository: docker.io/otel/opentelemetry-collector-contrib
    tag: 0.133.0
  replicas: 1
  service:
    type: ClusterIP
    ports:
      default:
        port: 8125
        protocol: UDP
      grpc:
        port: 4317
        protocol: UDP
      http:
        port: 4318
        protocol: TCP
  # configMap defines a ConfigMap associated with the component.
  # The contents of all entries are treated as Helm templates.
  # Some sample files are bundled with the chart. These files are intended for development use only.
  # Use "values.yaml" or the "--set-file" argument to replace the bundled files with your own.
  # Example: helm install dev . --set-file otelCollector.configMap.data.configuration=./custom.yaml
  configMap:
    data:
      configuration: "{{ .Files.Get \"files/otel-collector/config.yaml\" }}"
  volumeMounts:
    - name: config
      readOnly: true
      configMap:
        name: "{{ include \"common.fullnameWithComponent\" . }}"
        items:
          - key: configuration
            path: configuration
            mountPath: /etc/otelcol-contrib/config.yaml
            readOnly: true
  # startupProbe defines the criteria to mark the pod as running for the first time.
  # The "waitForComponents" init container relies on this probe to consider the component ready.
  # Ports and commands used in the probe are treated as Helm templates.
  startupProbe:
    initialDelaySeconds: 1
    periodSeconds: 1
    timeoutSeconds: 1
    failureThreshold: 10
    tcpSocket:
      port: "{{ .componentValues.service.ports.http.port }}"
# traefikResources defines the values to create Traefik resources for TLS termination and HTTP routing.
# These resources assume that both the Traefik and Traefik CRDs charts are installed in the cluster.
# In the "k3s" distribution, both charts are installed by default.
# This setup is intended for a self-contained local environment.
# Disable this component to use a different ingress gateway.
traefikResources:
  enabled: true
  # hostname configures the DNS name that will be used to access Flatline. Required.
  hostname: flatline.localhost
  # chart references the existing Traefik chart. Optional.
  chart:
    # name references the name of the Traefik chart that is installed. Optional.
    name: traefik
    # namespace references the namespace where the Traefik chart is installed. Optional.
    # In the "k3s" distribution, the chart is pre-installed in the "kube-system" namespace.
    namespace: kube-system
    # valuesOverride can be used to override values from an existing Traefik chart managed by Helm. Optional.
    # This is done with the creation of a HelmChartConfig, which must be supported by your Kubernetes distribution.
    # In the "k3s" distribution, HelmChartConfig is the recommended way of customizing the bundled Traefik.
    valuesOverride:
      global:
        sendAnonymousUsage: false
  # secret defines a Secret associated with the component.
  # The contents of all entries are treated as Helm templates.
  # Some sample files are bundled with the chart. These files are intended for development use only.
  # Use "values.yaml" or the "--set-file" argument to replace the bundled files with your own.
  # Example: helm install dev . --set-file traefikResources.secret.stringData."tls.key"=./custom.key
  secret:
    type: kubernetes.io/tls
    stringData:
      tls.crt: "{{ .Files.Get \"files/traefik/wildcard-localhost.pem\" }}"
      tls.key: "{{ .Files.Get \"files/traefik/wildcard-localhost.key.pem\" }}"
  # tls configures how Traefik will terminate TLS connections to Flatline. Required.
  tls:
    # secretName can be used to reference an existing Kubernetes TLS secret with "tls.crt" and "tls.key" items.
    # When not set, the values defined in the "secret" section above are used.
    secretName: ""
    # optionsName can be used to reference existing options to use for TLS termination.
    # When not set, Traefik defaults are used.
    optionsName: ""
