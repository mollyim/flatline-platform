# global defines shared values for this chart and its dependencies.
global:
  # defaultStorageClass defines the default storage class used to create volumes for Flatline. Optional.
  # When not set, the default storage class configured for the cluster will be used.
  defaultStorageClass: ""
  # hostname defines the DNS name that clients will use to connect to Flatline. Required.
  # This name is used to perform subdomain-based routing and must match the certificate used in Traefik.
  # The default value, "flatline.internal", assumes a local mechanism of resolving the name.
  hostname: flatline.internal
  # advertisedAddress defines the address through which clients can reach the host running Flatline. Required.
  # This address used by components related to multimedia calling which must advertise their address to clients.
  # The default value, "10.0.2.2", assumes clients running on the Android Emulator and Flatline on the host.
  advertisedAddress: "10.0.2.2"
# common defines shared values for this chart.
common:
  # defaultInitContainer defines the values to be used by default in various init containers.
  # Components defined with an "initContainer" object create a container that will use these defaults.
  # The "waitForComponents" object also creates an init container that will use these defaults.
  defaultInitContainer:
    image:
      repository: docker.io/library/busybox
      tag: 1.36.1
      pullPolicy: IfNotPresent
#
#  Flatline Components
#  These components are the core of Flatline.
#  Their container images are built by the Flatline project.
#
# whisperService defines the values for the Whisper Service component.
whisperService:
  enabled: true
  image:
    repository: ghcr.io/mollyim/flatline-whisper-service
    tag: main
    pullPolicy: Always
  replicas: 1
  container:
    command: java
    args:
      - -server
      - -Djava.awt.headless=true
      - -Djdk.nio.maxCachedBufferSize=262144
      - -Dlog4j2.formatMsgNoLookups=true
      - -Dsecrets.bundle.filename=/usr/share/signal/sample-secrets-bundle.yml
      - -XX:MaxRAMPercentage=75
      - -XX:+HeapDumpOnOutOfMemoryError
      - -XX:HeapDumpPath=/tmp/heapdump.bin
      - -cp
      - /app/resources:/app/classes:/app/libs/*
      - org.whispersystems.textsecuregcm.WhisperServerService
      - server
      - /usr/share/signal/dev.yml
      # Other useful arguments:
      # Generate ZK parameters:
      #   - zkparams
      # Generate CA for unidentified delivery:
      #   - certificate
      #   - --ca
      # Generate certificate for unidentified delivery:
      #   - certificate
      #   - --key=<ca-private-key>
      #   - --id=<certificate-serial-number>
  service:
    type: ClusterIP
    ports:
      default:
        port: 8080
        protocol: TCP
      admin:
        port: 8081
        protocol: TCP
  # env defines the environment variables passed to the container.
  # In this chart, environment variable values are treated as Helm templates.
  env:
    - name: AWS_REGION
      value: us-east-1
    - name: AWS_ACCESS_KEY_ID
      value: test
    - name: AWS_SECRET_ACCESS_KEY
      value: test
    - name: AWS_ENDPOINT_OVERRIDE
      value: "http://{{ include \"common.fullname\" . }}-localstack:4566"
    - name: SIGNAL_DISABLE_LOGSTASH_TCP_SOCKET_APPENDER
      value: "1"
  # configMap defines a ConfigMap associated with the component.
  # The contents of all entries are treated as Helm templates.
  # Some sample files are bundled with the chart. These files are intended for development use only.
  # Use "values.yaml" or the "--set-file" argument to replace the bundled files with your own.
  # Example: helm install dev . --set-file whisperService.configMap.data.configuration=./custom.yml
  configMap:
    data:
      configuration: "{{ tpl (.Files.Get \"files/whisper-service/dev.yml\") . }}"
  # secret defines a Secret associated with the component.
  # The contents of all entries are treated as Helm templates.
  # Some sample files are bundled with the chart. These files are intended for development use only.
  # Use "values.yaml" or the "--set-file" argument to replace the bundled files with your own.
  # Example: helm install dev . --set-file whisperService.secret.stringData.secrets-bundle=./custom.yml
  secret:
    data:
      noise-tunnel-keystore: "{{ .Files.Get \"files/whisper-service/noise-tunnel-keystore.p12\" | b64enc }}"
    stringData:
      secrets-bundle: "{{ .Files.Get \"files/whisper-service/sample-secrets-bundle.yml\" }}"
  volumeMounts:
    - name: config
      readOnly: true
      configMap:
        name: "{{ include \"common.fullnameWithComponent\" . }}"
        items:
          - key: configuration
            path: configuration
            mountPath: /usr/share/signal/dev.yml
            readOnly: true
    - name: secrets
      readOnly: true
      secret:
        name: "{{ include \"common.fullnameWithComponent\" . }}"
        items:
          - key: secrets-bundle
            path: secrets-bundle
            mountPath: /usr/share/signal/sample-secrets-bundle.yml
            readOnly: true
          - key: noise-tunnel-keystore
            path: noise-tunnel-keystore
            mountPath: /usr/share/signal/noise-tunnel-keystore.p12
            readOnly: true
  # initContainer defines a process that must succeed during pod initialization.
  initContainer:
    image:
      repository: docker.io/library/redis
      tag: 8.2.1
    command: sh
    # args defines the arguments passed to the entrypoint command.
    # Each argument is treated as a Helm template.
    args:
      - -c
      # Ensure that the Redis cluster has all of its nodes.
      - |
        REDIS_HOST="{{ include "common.fullname" . }}-redis-cluster"
        REDIS_PORT={{ .Values.redisCluster.service.ports.default.port }}
        EXPECTED_NODES={{ .Values.redisCluster.replicas }}
        redis-cli -h "${REDIS_HOST}" -p ${REDIS_PORT} --raw CLUSTER INFO \
          | grep -E 'cluster_state|cluster_known_nodes' && \
        test "$(redis-cli -h "${REDIS_HOST}" -p ${REDIS_PORT} CLUSTER NODES | wc -l)" -eq ${EXPECTED_NODES}
  # waitForCompoenents defines the a map of component services to wait for during pod initialization.
  # Both the host and the port for each container are treated as Helm templates.
  waitForComponents:
    localstack:
      type: tcp
      host: "{{ include \"common.fullname\" . }}-localstack"
      port: "{{ .Values.localstack.service.ports.default.port }}"
    cbtemulator:
      type: tcp
      host: "{{ include \"common.fullname\" . }}-cbtemulator"
      port: "{{ .Values.cbtemulator.service.ports.default.port }}"
    tus:
      type: tcp
      host: "{{ include \"common.fullname\" . }}-tus"
      port: "{{ .Values.tus.service.ports.default.port }}"
    redisCluster:
      type: tcp
      host: "{{ include \"common.fullname\" . }}-redis-cluster"
      port: "{{ .Values.redisCluster.service.ports.default.port }}"
    otelCollector:
      type: tcp
      host: "{{ include \"common.fullname\" . }}-otel-collector"
      port: "{{ .Values.otelCollector.service.ports.http.port }}"
    registrationService:
      type: tcp
      host: "{{ include \"common.fullname\" . }}-registration-service"
      port: "{{ .Values.registrationService.service.ports.default.port }}"
  # startupProbe defines the criteria to mark the pod as running for the first time.
  # The "waitForComponents" init container relies on this probe to consider the component ready.
  # Ports and commands used in the probe are treated as Helm templates.
  startupProbe:
    initialDelaySeconds: 1
    periodSeconds: 1
    timeoutSeconds: 1
    failureThreshold: 20
    tcpSocket:
      port: "{{ .componentValues.service.ports.default.port }}"
# storageService defines the values for the Storage Service component.
storageService:
  enabled: true
  image:
    repository: ghcr.io/mollyim/flatline-storage-service
    tag: main
    pullPolicy: Always
  replicas: 1
  service:
    type: ClusterIP
    ports:
      default:
        port: 10080
        protocol: TCP
      admin:
        port: 10081
        protocol: TCP
  # env defines the environment variables passed to the container.
  # In this chart, environment variable values are treated as Helm templates.
  env:
    - name: AWS_REGION
      value: us-east-1
    - name: HTTP_HOST
      value: "0.0.0.0"
    - name: HTTP_PORT
      value: "{{ .Values.storageService.service.ports.default.port }}"
    - name: ADMIN_HOST
      value: "0.0.0.0"
    - name: ADMIN_HTTP_PORT
      value: "{{ .Values.storageService.service.ports.admin.port }}"
    - name: BIGTABLE_EMULATOR_HOST
      value: "{{ include \"common.fullname\" . }}-cbtemulator:{{ .Values.cbtemulator.service.ports.default.port }}"
  # configMap defines a ConfigMap associated with the component.
  # The contents of all entries are treated as Helm templates.
  # Some sample files are bundled with the chart. These files are intended for development use only.
  # Use "values.yaml" or the "--set-file" argument to replace the bundled files with your own.
  # Example: helm install dev . --set-file storageService.configMap.data.configuration=./custom.yml
  configMap:
    data:
      configuration: "{{ tpl (.Files.Get \"files/storage-service/dev.yml\") . }}"
  volumeMounts:
    - name: config
      readOnly: false
      configMap:
        name: "{{ include \"common.fullnameWithComponent\" . }}"
        items:
          - key: configuration
            path: configuration
            mountPath: /usr/share/signal/dev.yml
            readOnly: true
  # waitForCompoenents defines the a map of component services to wait for during pod initialization.
  # Both the host and the port for each container are treated as Helm templates.
  waitForComponents:
    cbtemulator:
      type: tcp
      host: "{{ include \"common.fullname\" . }}-cbtemulator"
      port: "{{ .Values.cbtemulator.service.ports.default.port }}"
  # startupProbe defines the criteria to mark the pod as running for the first time.
  # The "waitForComponents" init container relies on this probe to consider the component ready.
  # Ports and commands used in the probe are treated as Helm templates.
  startupProbe:
    initialDelaySeconds: 1
    periodSeconds: 1
    timeoutSeconds: 1
    failureThreshold: 20
    tcpSocket:
      port: "{{ .componentValues.service.ports.default.port }}"
# registrationService defines the values for the Registration Service component.
registrationService:
  enabled: true
  image:
    repository: ghcr.io/mollyim/flatline-registration-service
    tag: main
    pullPolicy: Always
  replicas: 1
  service:
    type: ClusterIP
    ports:
      default:
        port: 50051
        protocol: TCP
  # startupProbe defines the criteria to mark the pod as running for the first time.
  # The "waitForComponents" init container relies on this probe to consider the component ready.
  # Ports and commands used in the probe are treated as Helm templates.
  startupProbe:
    initialDelaySeconds: 1
    periodSeconds: 1
    timeoutSeconds: 1
    failureThreshold: 10
    tcpSocket:
      port: "{{ .componentValues.service.ports.default.port }}"
# contactDiscoveryService defines the values for the Contact Discovery Service component.
contactDiscoveryService:
  enabled: false # This component is disabled by default. It requires running on Intel SGX hardware.
  image:
    repository: ghcr.io/mollyim/flatline-contact-discovery-service
    tag: main
    pullPolicy: Always
  replicas: 1
  service:
    type: ClusterIP
    ports:
      default:
        port: 8080
        protocol: TCP
  # startupProbe defines the criteria to mark the pod as running for the first time.
  # The "waitForComponents" init container relies on this probe to consider the component ready.
  # Ports and commands used in the probe are treated as Helm templates.
  startupProbe:
    initialDelaySeconds: 1
    periodSeconds: 1
    timeoutSeconds: 1
    failureThreshold: 10
    tcpSocket:
      port: "{{ .componentValues.service.ports.default.port }}"
# callingServiceFrontend defines the values for the Calling Service frontend component.
# This component is required for multimedia calls.
callingServiceFrontend:
  enabled: true
  image:
    repository: ghcr.io/mollyim/flatline-calling-service-frontend
    tag: main
    pullPolicy: Always
  replicas: 1
  container:
    command: calling_frontend
    args:
      - --region
      - "{{ include \"common.fullname\" . }}" # This region is only used for tagging metrics and logs.
      - --authentication-key
      # Same as group.externalServiceSecret configured in storage service.
      - "3f9b8e5f981f7d5b31d86e0ba883837fdd65e6ea375a698a28fa1f1e468a9a21"
      - --zkparams
      # Same as callingZkConfig.serverSecret configured in Whisper service.
      - "AMWhaRyvktoOYc8kkTAeb8urCwKtqiNnrpD3gcD9pn0BNWXwIAx/U6lRJSISUP0F4m+G4Pzrpk/WjyFMXbHuag+Up3cTD0zmVsTA9wPmfthbhwU1XseBLTlk+63MNQ3EWS8JYgbyWeSqFx0t+peN743xylkXyKxn6W5ltk1SKicIWLrf2ddW6MdBBtZUN1fO6wguwBIKxwNB6svSqEalsA2pklQF+otRhapkcQEKoI0zN/rq8yqklBYDrtGaKvTHB/pwontP+flig0cGCjOx11YwSe9JxKABRAdHzP7MVBEChwjuUzNBa1YWo3FbAyXRuQWYv6JwZzC87dkBzXplfwq6IZ/HGz3h2Vf+m++9nIGoIKeBv5MHxCUWeLctcp78C5F0BphW7DqtekJuZGfDDyF6rGxG4o47eQqI+WL+C5sCay60HjsqJCesqw9LqLbuDEbS1rdYSxOPtp6BbtISIAJjAx23PIF5mYAL/YRihaiXut4sYa5ziq6Bexe4HpuOCw=="
      - --version
      - "1"
      - --max-clients-per-call
      - "50"
      - --cleanup-interval-ms
      - "10000"
      - --regional-url-template
      - "http://{{ include \"common.fullname\" . }}-calling-service-frontend:{{ .Values.callingServiceFrontend.service.ports.default.port }}"
      - --calling-server-url
      - "http://{{ include \"common.fullname\" . }}-calling-service-backend:{{ .Values.callingServiceBackend.service.ports.default.port }}"
      - --storage-table
      - "Rooms"
      - --storage-endpoint
      - "http://{{ include \"common.fullname\" . }}-localstack:{{ .Values.localstack.service.ports.default.port }}"
      - --storage-region
      - "us-east-1"
      - --internal-api-port
      - "8100"
  service:
    type: ClusterIP
    ports:
      default:
        port: 8080
        protocol: TCP
      api:
        port: 8100
        protocol: TCP
  # waitForCompoenents defines the a map of component services to wait for during pod initialization.
  # Both the host and the port for each container are treated as Helm templates.
  waitForComponents:
    localstack:
      type: tcp
      host: "{{ include \"common.fullname\" . }}-localstack"
      port: "{{ .Values.localstack.service.ports.default.port }}"
    callingServiceBackend:
      type: tcp
      host: "{{ include \"common.fullname\" . }}-calling-service-backend"
      port: "{{ .Values.callingServiceBackend.service.ports.default.port }}"
  # startupProbe defines the criteria to mark the pod as running for the first time.
  # The "waitForComponents" init container relies on this probe to consider the component ready.
  # Ports and commands used in the probe are treated as Helm templates.
  startupProbe:
    initialDelaySeconds: 1
    periodSeconds: 1
    timeoutSeconds: 1
    failureThreshold: 10
    tcpSocket:
      port: "{{ .componentValues.service.ports.api.port }}"
# callingServiceBackend defines the values for the Calling Service backend component.
# This component is required for multimedia calls.
callingServiceBackend:
  enabled: true
  image:
    repository: ghcr.io/mollyim/flatline-calling-service-backend
    tag: main
    pullPolicy: Always
  replicas: 1
  hostNetwork: true
  strategy: Recreate # Required due to host networking.
  container:
    command: calling_backend
    args:
      - --ice-candidate-ip
      - "{{ .Values.global.advertisedAddress }}"
      - --signaling-ip
      - "{{ .Values.global.advertisedAddress }}"
      - --ice-candidate-port
      - "10000"
      - --ice-candidate-port-tcp
      - "10000"
      - --inactivity-timeout-secs
      - "60"
      - --diagnostics-interval-secs
      - "10"
      - --approved-users-persistence-url
      - "http://{{ include \"common.fullname\" . }}-calling-service-frontend:{{ .Values.callingServiceFrontend.service.ports.api.port }}/v1/call-link-approvals"
      - --remove-call-records-base-url
      - "http://{{ include \"common.fullname\" . }}-calling-service-frontend:{{ .Values.callingServiceFrontend.service.ports.api.port }}/v2/conference"
  service:
    type: ClusterIP
    ports:
      # These ports are only for reference, as this component uses the host network.
      default:
        port: 8080
        protocol: TCP
      icetcp:
        port: 10000
        protocol: TCP
      iceudp:
        port: 10000
        protocol: UDP
  # startupProbe defines the criteria to mark the pod as running for the first time.
  # The "waitForComponents" init container relies on this probe to consider the component ready.
  # Ports and commands used in the probe are treated as Helm templates.
  startupProbe:
    initialDelaySeconds: 1
    periodSeconds: 1
    timeoutSeconds: 1
    failureThreshold: 10
    tcpSocket:
      port: "{{ .componentValues.service.ports.default.port }}"
#
#  Infrastructure Components
#  These components provide functionality that Flatline requires.
#  Their container images are build and distributed by third parties.
#  They are bundled in the chart to provide a functional development environment.
#  They should be replaced with production-ready alternatives when appropriate.
#
# localstack defines the creation and bootstrapping of an environment emulating Amazon Web Services.
# The DynamoDB and S3 features from AWS are required by the Whisper Service component.
# Disable this component to use AWS or another compatible solution.
localstack:
  enabled: true
  image:
    repository: docker.io/localstack/localstack
    tag: 4.6.0
    pullPolicy: IfNotPresent
  service:
    type: ClusterIP
    ports:
      default:
        port: 4566
        protocol: TCP
  replicas: 1
  # startupProbe defines the criteria to mark the pod as running for the first time.
  # The "waitForComponents" init container relies on this probe to consider the component ready.
  # Ports and commands used in the probe are treated as Helm templates.
  startupProbe:
    initialDelaySeconds: 5
    periodSeconds: 1
    timeoutSeconds: 1
    failureThreshold: 60
    exec:
      command:
        - sh
        - -c
        - "curl -s localhost:{{ .componentValues.service.ports.default.port }}/_localstack/init/ready | grep '\"completed\": true'"
  # env defines the environment variables passed to the container.
  # In this chart, environment variable values are treated as Helm templates.
  env:
    - name: DISABLE_EVENTS
      value: "1"
    - name: LS_LOG
      value: info
  persistence:
    # storageClassName defines the storage class that will be used by the created persistent volume. Optional.
    # When not set, the global "defaultStorageClass" will be used.
    storageClassName: ""
    accessModes:
      - ReadWriteOnce
    size: 1Gi
  # configMap defines a ConfigMap associated with the component.
  # The contents of all entries are treated as Helm templates.
  # Some sample files are bundled with the chart. These files are intended for development use only.
  # Use "values.yaml" or the "--set-file" argument to replace the bundled files with your own.
  # Example: helm install dev . --set-file localstack.configMap.data.whisper-service-dynamic-configuration=./custom.yaml
  configMap:
    data:
      init-script: "{{ .Files.Get \"files/localstack/init.sh\" }}"
      flatline-resources: "{{ .Files.Get \"files/localstack/flatline-resources.yaml\" }}"
      whisper-service-dynamic-configuration: "{{ .Files.Get \"files/localstack/whisper-service-dynamic-config-dev.yaml\" }}"
  volumeMounts:
    - name: config
      readOnly: false
      configMap:
        name: "{{ include \"common.fullnameWithComponent\" . }}"
        defaultMode: "0755"
        items:
          - key: init-script
            path: init-script
            mountPath: /etc/localstack/init/ready.d/init.sh
            readOnly: true
          - key: flatline-resources
            path: flatline-resources
            mountPath: /opt/flatline-resources.yaml
            readOnly: true
          - key: whisper-service-dynamic-configuration
            path: whisper-service-dynamic-configuration
            mountPath: /opt/whisper-service-dynamic-config-dev.yaml
            readOnly: true
    - name: data
      mountPath: /var/lib/localstack
      readOnly: false
      persistentVolumeClaim:
        claimName: "{{ include \"common.fullnameWithComponent\" . }}"
# cbtemulator defines the creation of an environment emulating Google Cloud Bigtable.
# The Bigtable feature from GCP is required by the Storage Service component.
# Disable this component to use Bigtable on GCP or another compatible solution.
cbtemulator:
  enabled: true
  image:
    repository: docker.io/fullstorydev/cbtemulator
    tag: v1.0.0
    pullPolicy: IfNotPresent
  service:
    type: ClusterIP
    ports:
      default:
        port: 9000
        protocol: TCP
  replicas: 1
  container:
    command: cbtemulator
    # args defines the arguments passed to the entrypoint command.
    # Each argument is treated as a Helm template.
    args:
      - -host
      - 0.0.0.0
      - -port
      - "{{ .componentValues.service.ports.default.port }}"
      - -dir
      - /var/bigtable
  job:
    image:
      repository: docker.io/google/cloud-sdk
      tag: 541.0.0
    command: sh
    # args defines the arguments passed to the entrypoint command.
    # Each argument is treated as a Helm template.
    args:
      - -c
      - "{{ tpl (.Files.Get \"files/cbtemulator/init.sh.tpl\") . }}"
  persistence:
    # storageClassName defines the storage class that will be used by the created persistent volume. Optional.
    # When not set, the global "defaultStorageClass" will be used.
    storageClassName: ""
    accessModes:
      - ReadWriteOnce
    size: 1Gi
  volumeMounts:
    - name: data
      mountPath: /var/bigtable
      readOnly: false
      persistentVolumeClaim:
        claimName: "{{ include \"common.fullnameWithComponent\" . }}"
  # startupProbe defines the criteria to mark the pod as running for the first time.
  # The "waitForComponents" init container relies on this probe to consider the component ready.
  # Ports and commands used in the probe are treated as Helm templates.
  startupProbe:
    initialDelaySeconds: 5
    periodSeconds: 1
    timeoutSeconds: 1
    failureThreshold: 5
    tcpSocket:
      port: "{{ .componentValues.service.ports.default.port }}"
# tus defines the values for the a resumable file uploads server.
# Such a server is required by the Whisper Service component.
# Disable this component to use an alternative implementation.
tus:
  enabled: true
  image:
    repository: ghcr.io/tus/tusd
    tag: v2.8.0
    pullPolicy: IfNotPresent
  replicas: 1
  container:
    command: /usr/local/share/docker-entrypoint.sh
    # args defines the arguments passed to the entrypoint command.
    # Each argument is treated as a Helm template.
    args:
      - --upload-dir
      - /srv/tusd-data/data
      # Serve in the path expected by the application.
      - --base-path
      - /attachments/
      # Configure custom hook to handle uploads.
      - --hooks-dir
      - /srv/tusd-hooks
      - --hooks-enabled-events
      - pre-create
      # Disable handling termination requests.
      - --disable-termination
  service:
    type: ClusterIP
    ports:
      default:
        port: 8080
        protocol: TCP
  persistence:
    # storageClassName defines the storage class that will be used by the created persistent volume. Optional.
    # When not set, the global "defaultStorageClass" will be used.
    storageClassName: ""
    accessModes:
      - ReadWriteOnce
    size: 10Gi
  # configMap defines a ConfigMap associated with the component.
  # The contents of all entries are treated as Helm templates.
  # Some sample files are bundled with the chart. These files are intended for development use only.
  # Use "values.yaml" or the "--set-file" argument to replace the bundled files with your own.
  # Example: helm install dev . --set-file tus.configMap.data.pre-finish=./pre-finish
  configMap:
    data:
      pre-create: "{{ .Files.Get \"files/tus/pre-create\" }}"
  volumeMounts:
    - name: data
      mountPath: /srv/tusd-data/data
      readOnly: false
      persistentVolumeClaim:
        claimName: "{{ include \"common.fullnameWithComponent\" . }}"
    - name: hooks
      configMap:
        defaultMode: 0755
        name: "{{ include \"common.fullnameWithComponent\" . }}"
        items:
          - key: pre-create
            path: pre-create
            mountPath: /srv/tusd-hooks/pre-create
  # startupProbe defines the criteria to mark the pod as running for the first time.
  # The "waitForComponents" init container relies on this probe to consider the component ready.
  # Ports and commands used in the probe are treated as Helm templates.
  startupProbe:
    initialDelaySeconds: 1
    periodSeconds: 1
    timeoutSeconds: 1
    failureThreshold: 10
    tcpSocket:
      port: "{{ .componentValues.service.ports.default.port }}"
# redisCluster defines the values for an insecure development Redis cluster.
# Such a cluster is required by the Whisper Service component.
# Disable this component to use a production Redis cluster.
redisCluster:
  enabled: true
  image:
    repository: docker.io/library/redis
    tag: 8.2.1
    pullPolicy: IfNotPresent
  replicas: 6
  cluster:
    replicasPerMaster: 1
  container:
    command: redis-server
    # args defines the arguments passed to the entrypoint command.
    # Each argument is treated as a Helm template.
    args:
      - /etc/redis/redis.conf
  service:
    type: ClusterIP
    clusterIP: None
    ports:
      default:
        port: 6379
        protocol: TCP
  persistence:
    # storageClassName defines the storage class that will be used by the created persistent volume. Optional.
    # When not set, the global "defaultStorageClass" will be used.
    storageClassName: ""
    accessModes:
      - ReadWriteOnce
    size: 1Gi
  # configMap defines a ConfigMap associated with the component.
  # The contents of all entries are treated as Helm templates.
  # Some sample files are bundled with the chart. These files are intended for development use only.
  # Use "values.yaml" or the "--set-file" argument to replace the bundled files with your own.
  # Example: helm install dev . --set-file redisCluster.configMap.data.configuration=./custom.conf
  configMap:
    data:
      configuration: "{{ .Files.Get \"files/redis-cluster/redis.conf\" }}"
  volumeMounts:
    - name: data
      mountPath: /data
      readOnly: false
    - name: config
      readOnly: true
      configMap:
        name: "{{ include \"common.fullnameWithComponent\" . }}"
        items:
          - key: configuration
            path: configuration
            mountPath: /etc/redis/redis.conf
            readOnly: true
  job:
    command: sh
    # args defines the arguments passed to the entrypoint command.
    # Each argument is treated as a Helm template.
    args:
      - -c
      - "{{ tpl (.Files.Get \"files/redis-cluster/init.sh.tpl\") . }}"
  # startupProbe defines the criteria to mark the pod as running for the first time.
  # The "waitForComponents" init container relies on this probe to consider the component ready.
  # Ports and commands used in the probe are treated as Helm templates.
  startupProbe:
    initialDelaySeconds: 5
    periodSeconds: 1
    timeoutSeconds: 1
    failureThreshold: 60
    tcpSocket:
      port: "{{ .componentValues.service.ports.default.port }}"
# coturn defines the values for a TURN server used for WebRTC calling.
# This component is required for multimedia calls.
coturn:
  enabled: true
  image:
    repository: docker.io/coturn/coturn
    tag: 4.7.0-alpine
    pullPolicy: IfNotPresent
  replicas: 1
  hostNetwork: true
  strategy: Recreate # Required due to host networking.
  container:
    command: docker-entrypoint.sh
    args:
      - --log-file=stdout
  service:
    type: ClusterIP
    ports:
      # These ports are only for reference, as this component uses the host network.
      turntcp:
        port: 3478
        protocol: TCP
      turnudp:
        port: 3478
        protocol: UDP
      # Additional ports 49152 to 65535 UDP used as relay endpoints.
  # configMap defines a ConfigMap associated with the component.
  # The contents of all entries are treated as Helm templates.
  # Some sample files are bundled with the chart. These files are intended for development use only.
  # Use "values.yaml" or the "--set-file" argument to replace the bundled files with your own.
  # Example: helm install dev . --set-file coturn.configMap.data.configuration=./custom.conf
  configMap:
    data:
      configuration: "{{ tpl (.Files.Get \"files/coturn/turnserver.conf.tpl\") . }}"
  volumeMounts:
    - name: config
      readOnly: true
      configMap:
        name: "{{ include \"common.fullnameWithComponent\" . }}"
        items:
          - key: configuration
            path: configuration
            mountPath: /etc/coturn/turnserver.conf
            readOnly: true
  # startupProbe defines the criteria to mark the pod as running for the first time.
  # The "waitForComponents" init container relies on this probe to consider the component ready.
  # Ports and commands used in the probe are treated as Helm templates.
  startupProbe:
    initialDelaySeconds: 5
    periodSeconds: 1
    timeoutSeconds: 1
    failureThreshold: 60
    tcpSocket:
      port: "{{ .componentValues.service.ports.turntcp.port }}"
# otelCollector defines the values for an OpenTelemetry collector.
# A collector compatible with StatsD is required by the Whisper Service component.
# Disable this component to use an existing StatsD collector.
otelCollector:
  enabled: true
  image:
    repository: docker.io/otel/opentelemetry-collector-contrib
    tag: 0.133.0
  replicas: 1
  service:
    type: ClusterIP
    ports:
      default:
        port: 8125
        protocol: UDP
      grpc:
        port: 4317
        protocol: UDP
      http:
        port: 4318
        protocol: TCP
  # configMap defines a ConfigMap associated with the component.
  # The contents of all entries are treated as Helm templates.
  # Some sample files are bundled with the chart. These files are intended for development use only.
  # Use "values.yaml" or the "--set-file" argument to replace the bundled files with your own.
  # Example: helm install dev . --set-file otelCollector.configMap.data.configuration=./custom.yaml
  configMap:
    data:
      configuration: "{{ .Files.Get \"files/otel-collector/config.yaml\" }}"
  volumeMounts:
    - name: config
      readOnly: true
      configMap:
        name: "{{ include \"common.fullnameWithComponent\" . }}"
        items:
          - key: configuration
            path: configuration
            mountPath: /etc/otelcol-contrib/config.yaml
            readOnly: true
  # startupProbe defines the criteria to mark the pod as running for the first time.
  # The "waitForComponents" init container relies on this probe to consider the component ready.
  # Ports and commands used in the probe are treated as Helm templates.
  startupProbe:
    initialDelaySeconds: 1
    periodSeconds: 1
    timeoutSeconds: 1
    failureThreshold: 10
    tcpSocket:
      port: "{{ .componentValues.service.ports.http.port }}"
# traefikResources defines the values to create Traefik resources for TLS termination and HTTP routing.
# These resources assume that both the Traefik and Traefik CRDs charts are installed in the cluster.
# In the "k3s" distribution, both charts are installed by default.
# This setup is intended for a self-contained local environment.
# Disable this component to use a different ingress gateway.
traefikResources:
  enabled: true
  # chart references the existing Traefik chart. Optional.
  chart:
    # name references the name of the Traefik chart that is installed. Optional.
    name: traefik
    # namespace references the namespace where the Traefik chart is installed. Optional.
    # In the "k3s" distribution, the chart is pre-installed in the "kube-system" namespace.
    namespace: kube-system
    # valuesOverride can be used to override values from an existing Traefik chart managed by Helm. Optional.
    # This is done with the creation of a HelmChartConfig, which must be supported by your Kubernetes distribution.
    # In the "k3s" distribution, HelmChartConfig is the recommended way of customizing the bundled Traefik.
    valuesOverride:
      global:
        sendAnonymousUsage: false
  # secret defines a Secret associated with the component.
  # The contents of all entries are treated as Helm templates.
  # Some sample files are bundled with the chart. These files are intended for development use only.
  # Use "values.yaml" or the "--set-file" argument to replace the bundled files with your own.
  # Example: helm install dev . --set-file traefikResources.secret.stringData."tls.key"=./custom.key
  secret:
    type: kubernetes.io/tls
    stringData:
      tls.crt: "{{ .Files.Get \"files/traefik/wildcard-internal.pem\" }}"
      tls.key: "{{ .Files.Get \"files/traefik/wildcard-internal.key.pem\" }}"
  # tls configures how Traefik will terminate TLS connections to Flatline. Required.
  tls:
    # secretName can be used to reference an existing Kubernetes TLS secret with "tls.crt" and "tls.key" items.
    # When not set, the values defined in the "secret" section above are used.
    secretName: ""
    # optionsName can be used to reference existing options to use for TLS termination.
    # When not set, Traefik defaults are used.
    optionsName: ""
